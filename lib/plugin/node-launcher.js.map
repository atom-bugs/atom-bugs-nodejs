{"version":3,"file":"node-launcher.js","sourceRoot":"","sources":["../../src/plugin/node-launcher.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,mEAAwF;AACxF,6BAA8B;AAE9B;IAAkC,gCAA+B;IAAjE;;IA2BA,CAAC;IArBC,oCAAa,GAAb,UAAe,GAAG;QAChB,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IAC5C,CAAC;IACD,2CAAoB,GAApB;QACE,MAAM,CAAC;YACL,WAAW;YACX,iBAAe,IAAI,CAAC,UAAY;YAChC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC;SACpC,CAAC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAA;IAChC,CAAC;IACD,wCAAiB,GAAjB;QACE,MAAM,CAAC;YACL,QAAQ,EAAE,IAAI;YACd,KAAK,EAAE,IAAI;YACX,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,aAAa,CAAC,cAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC7D,GAAG,EAAE,IAAI,CAAC,oBAAoB;SAC/B,CAAA;IACH,CAAC;IACD,oCAAa,GAAb;QACE,MAAM,CAAC,IAAI,CAAC,UAAU,CAAA;IACxB,CAAC;IACH,mBAAC;AAAD,CAAC,AA3BD,CAAkC,0CAA+B,GA2BhE;AA3BY,oCAAY","sourcesContent":["import { ChromeDebuggingProtocolLauncher } from 'atom-bugs-chrome-debugger/lib/launcher'\nimport { dirname } from 'path'\n\nexport class NodeLauncher extends ChromeDebuggingProtocolLauncher {\n  public binaryPath: string\n  public launchArguments: Array<string>\n  public environmentVariables: Object\n  public cwd: string\n  public scriptPath: string\n  normalizePath (dir) {\n    return dir.replace(/^~/, process.env.HOME)\n  }\n  getLauncherArguments () {\n    return [\n      `--inspect`,\n      `--debug-brk=${this.portNumber}`,\n      this.normalizePath(this.scriptPath)\n    ].concat(this.launchArguments)\n  }\n  getProcessOptions () {\n    return {\n      detached: true,\n      shell: true,\n      cwd: this.cwd || this.normalizePath(dirname(this.scriptPath)),\n      env: this.environmentVariables\n    }\n  }\n  getBinaryPath (): string {\n    return this.binaryPath\n  }\n}\n\n\n// import { EventEmitter }  from 'events'\n// import { spawn, ChildProcess } from 'child_process'\n// import { request } from 'http'\n// import { type, arch } from 'os'\n// import { dirname } from 'path'\n//\n// export interface Page {\n//   type: string,\n//   url: string,\n//   webSocketDebuggerUrl?: string\n// }\n//\n// export type Pages = Array<Page>\n//\n// export class NodeLauncher {\n//\n//   public portNumber: number\n//   public hostName: string\n//   public binaryPath: string\n//\n//   private process: ChildProcess\n//   private maxAttempts: number = 3\n//   private attempt: number = 0\n//   private events: EventEmitter = new EventEmitter()\n//   // Events\n//   didStop (cb) {\n//     this.events.on('didStop', cb)\n//   }\n//   didFail (cb) {\n//     this.events.on('didFail', cb)\n//   }\n//   didReceiveOutput(cb) {\n//     this.events.on('didReceiveOutput', cb)\n//   }\n//   didReceiveError(cb) {\n//     this.events.on('didReceiveError', cb)\n//   }\n//   normalizePath (dir) {\n//     return dir.replace(/^~/, process.env.HOME)\n//   }\n//   // Actions\n//   stop () {\n//     this.process.kill()\n//     this.process = null\n//     this.events.emit('didStop')\n//   }\n//   async start (): Promise<string> {\n//     let launchArgs = [\n//       `--inspect`,\n//       `--debug-brk=${this.portNumber}`,\n//       this.normalizePath(this.scriptPath)\n//     ].concat(this.launchArguments)\n//     let options = {\n//       detached: true,\n//       shell: true,\n//       cwd: this.cwd || this.normalizePath(dirname(this.scriptPath)),\n//       env: this.environmentVariables\n//     }\n//     let output = ''\n//     // kill if already running\n//     if (this.process) {\n//       await this.stop()\n//     }\n//     // process\n//     this.process = spawn(this.binaryPath, launchArgs, options)\n//     this.process.stdout.setEncoding('utf8')\n//     this.process.stderr.setEncoding('utf8')\n//     this.process.stdout.on('data', (res: Uint8Array) => {\n//       this.events.emit('didReceiveOutput', res.toString())\n//     })\n//     this.process.stderr.on('data', (res: Uint8Array) => {\n//       output = output.concat(res.toString())\n//       this.events.emit('didReceiveError', res)\n//     })\n//     this.process.stdout.on('end', (res: Uint8Array) => this.events.emit('didReceiveOutput', res))\n//     this.process.stderr.on('end', (res: Uint8Array) => this.events.emit('didReceiveError', res))\n//     this.process.on('close', (code: number) => {\n//       if (code !== 0) {\n//         this.events.emit('didFail')\n//       }\n//       this.events.emit('didStop')\n//     })\n//     return this.findSocketUrl()\n//   }\n//   getPages (): Promise<Pages> {\n//     return new Promise((resolve, reject) => {\n//       let req = request({\n//         hostname: this.hostName,\n//         port: this.portNumber,\n//         path: '/json',\n//         method: 'GET'\n//       }, (res) => {\n//         res.setEncoding('utf8')\n//         res.on('data', (chunk) => {\n//           try {\n//             resolve(JSON.parse(String(chunk)) as Pages)\n//           } catch (e) {\n//             reject(e)\n//           }\n//         })\n//       })\n//       req.on('error', reject)\n//       req.end()\n//     })\n//   }\n//   findSocketUrl (): Promise<string> {\n//     return new Promise((resolve, reject) => {\n//       setTimeout(async () => {\n//         let pages = await this\n//           .getPages()\n//           .catch(() => {\n//             if (this.attempt <= this.maxAttempts) {\n//               resolve(this.findSocketUrl())\n//             } else {\n//               reject('unable to get pages')\n//             }\n//           })\n//         let found = (pages || []).find((page: Page) => {\n//           return Boolean(page.webSocketDebuggerUrl)\n//         })\n//         if (found) {\n//           resolve(found.webSocketDebuggerUrl)\n//         } else {\n//           reject('unable to find page with socket')\n//         }\n//       }, 500)\n//     })\n//   }\n// }\n"]}