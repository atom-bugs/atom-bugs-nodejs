{"version":3,"file":"node-plugin.js","sourceRoot":"","sources":["../../src/plugin/node-plugin.ts"],"names":[],"mappings":"","sourcesContent":["// import { ChromeDebuggingProtocolPlugin } from 'xatom-debug-chrome-base/lib/plugin'\n//\n// import { NodeLauncher } from './node-launcher'\n// import { NodeDebugger } from './node-debugger'\n// import { Runtype, NodeOptions } from './node-options'\n//\n// import { watch, FSWatcher } from 'chokidar'\n// import { resolve as resolvePath, normalize } from 'path'\n// import { get, isUndefined, isString } from 'lodash'\n//\n// export class NodePlugin extends ChromeDebuggingProtocolPlugin {\n//\n//   public options: Object = NodeOptions\n//   public name: String = 'Node.js'\n//   public iconPath: String = 'atom://xatom-debug-nodejs/icons/nodejs.svg'\n//   public launcher: NodeLauncher = new NodeLauncher()\n//   public debugger: NodeDebugger = new NodeDebugger()\n//\n//   private watcher: FSWatcher\n//\n//   constructor () {\n//     super()\n//     this.addEventListeners()\n//   }\n//\n//   didLaunchError (message: string) {\n//     atom.notifications.addError('XAtom Debug: Node.js', {\n//       detail: `Launcher error: ${message}`,\n//       dismissable: true\n//     })\n//   }\n//\n//   async start (options: any) {\n//     try {\n//       let projectPath = this.pluginClient.getPath()\n//       let socketUrl\n//       this.debugger.skipFirstPause = true\n//       switch (options.runType) {\n//         case Runtype.CurrentFile:\n//         case Runtype.Script:\n//           if (options.runType === Runtype.CurrentFile) {\n//             let editor = atom.workspace.getActiveTextEditor()\n//             if (!isUndefined(editor)) {\n//               this.launcher.scriptPath = await this.normalizePath(editor.getPath())\n//             }\n//           } else {\n//             this.launcher.scriptPath = await this.normalizePath(options.scriptPath)\n//             this.launcher.cwd = await this.normalizePath(projectPath, true)\n//           }\n//           if (isString(this.launcher.scriptPath)) {\n//             this.launcher.binaryPath = await this.normalizePath(options.binaryPath, true)\n//             this.launcher.portNumber = options.port\n//             this.launcher.launchArguments = options.launchArguments\n//             this.launcher.environmentVariables = options.environmentVariables\n//             socketUrl = await this.launcher.start()\n//           }\n//           break\n//         case Runtype.Remote:\n//           this.launcher.hostName = options.remoteUrl\n//           this.launcher.portNumber = options.remotePort\n//           socketUrl = await this.launcher.getSocketUrl()\n//           break\n//       }\n//       if (socketUrl) {\n//         this.pluginClient.run()\n//         this.pluginClient.status.update('Connecting to debugger')\n//         await this\n//           .debugger\n//           .connect(socketUrl)\n//           .then(() => {\n//             this.pluginClient.status.update('Debugger attached', 'status-success')\n//             this.pluginClient.status.stopLoading()\n//           })\n//       }\n//     } catch (e) {\n//       this.pluginClient.status.update(e, 'status-error')\n//       this.pluginClient.status.stopLoading()\n//     }\n//   }\n//\n//   async restart (options) {\n//     await this.didStop()\n//     this.pluginClient.status.startLoading()\n//     this.pluginClient.status.update('Restarting to debugger')\n//     return this.start(options)\n//   }\n//\n//   // Actions\n//   async didRun () {\n//     this.pluginClient.status.startLoading()\n//     this.pluginClient.status.update('Running node')\n//     this.pluginClient.console.clear()\n//     let options = await this.pluginClient.getOptions()\n//     let projectPath = this.pluginClient.getPath()\n//     if (this.watcher) {\n//       this.watcher.close()\n//     }\n//     if (options.restartOnChanges) {\n//       this.watcher = watch(resolvePath(projectPath, options.changesPattern || ''), {\n//         ignored: [\n//           /[\\/\\\\]\\./,\n//           /node_modules/,\n//           /bower_components/\n//         ]\n//       })\n//       this\n//         .watcher\n//         .on('change', () => this.restart(options))\n//         .on('unlink', () => this.restart(options))\n//     }\n//     return this.start(options)\n//   }\n// }\n"]}